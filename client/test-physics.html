<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Test - Motosai</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
            background: #1a1a1a;
        }
        
        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            font-family: monospace;
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
        }
        
        #controls h3 {
            color: #00ff00;
            margin-bottom: 10px;
        }
        
        #speedometer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 48px;
            font-weight: bold;
            color: white;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.7);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="info">Loading...</div>
        <div id="speedometer">0 MPH</div>
        <div id="controls">
            <h3>Simple Physics Test</h3>
            <div>W/↑ - Throttle</div>
            <div>S/↓ - Brake</div>
            <div>A/← - Turn Left</div>
            <div>D/→ - Turn Right</div>
            <div>V - Toggle Physics Version</div>
            <div>R - Reset Position</div>
        </div>
    </div>
    
    <script type="module">
        import * as THREE from 'three';
        import { SimpleBikePhysics } from '/src/physics/SimpleBikePhysics.js';
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x404040, 10, 500);
        
        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('gameContainer').appendChild(renderer.domElement);
        
        // Camera
        const camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 5, -10);
        
        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        // Ground with grid
        const groundSize = 500;
        const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize);
        const groundMat = new THREE.MeshStandardMaterial({ 
            color: 0x333333,
            roughness: 0.8
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Grid helper
        const gridHelper = new THREE.GridHelper(groundSize, 50, 0x00ff00, 0x004400);
        scene.add(gridHelper);
        
        // Simple motorcycle
        const bikeGroup = new THREE.Group();
        
        // Body
        const bodyGeo = new THREE.BoxGeometry(0.4, 0.5, 2);
        const bodyMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 0.4;
        body.castShadow = true;
        bikeGroup.add(body);
        
        // Front wheel
        const wheelGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 16);
        const wheelMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
        const frontWheel = new THREE.Mesh(wheelGeo, wheelMat);
        frontWheel.rotation.z = Math.PI / 2;
        frontWheel.position.set(0, 0.3, 0.8);
        frontWheel.castShadow = true;
        bikeGroup.add(frontWheel);
        
        // Rear wheel
        const rearWheel = new THREE.Mesh(wheelGeo, wheelMat);
        rearWheel.rotation.z = Math.PI / 2;
        rearWheel.position.set(0, 0.3, -0.8);
        rearWheel.castShadow = true;
        bikeGroup.add(rearWheel);
        
        // Direction indicator (arrow)
        const arrowGeo = new THREE.ConeGeometry(0.2, 1, 4);
        const arrowMat = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
        const arrow = new THREE.Mesh(arrowGeo, arrowMat);
        arrow.position.set(0, 0.5, 1.5);
        arrow.rotation.x = -Math.PI / 2;
        bikeGroup.add(arrow);
        
        scene.add(bikeGroup);
        
        // Trail markers
        const trailMarkers = [];
        const maxTrailMarkers = 50;
        let markerCounter = 0;
        
        function addTrailMarker(position) {
            markerCounter++;
            if (markerCounter % 10 !== 0) return; // Only add every 10th frame
            
            const markerGeo = new THREE.SphereGeometry(0.1, 8, 8);
            const markerMat = new THREE.MeshBasicMaterial({ 
                color: new THREE.Color().setHSL((trailMarkers.length / maxTrailMarkers) * 0.3, 1, 0.5)
            });
            const marker = new THREE.Mesh(markerGeo, markerMat);
            marker.position.copy(position);
            marker.position.y = 0.1;
            scene.add(marker);
            trailMarkers.push(marker);
            
            if (trailMarkers.length > maxTrailMarkers) {
                const oldMarker = trailMarkers.shift();
                scene.remove(oldMarker);
            }
        }
        
        // Physics
        const physics = new SimpleBikePhysics();
        
        // Controls
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            
            if (e.code === 'KeyR') {
                physics.reset();
                // Clear trail
                trailMarkers.forEach(m => scene.remove(m));
                trailMarkers.length = 0;
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        // Update loop
        let lastTime = performance.now();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            // Update controls
            const controls = {
                throttle: 0,
                brake: 0,
                steer: 0
            };
            
            if (keys['KeyW'] || keys['ArrowUp']) controls.throttle = 1;
            if (keys['KeyS'] || keys['ArrowDown']) controls.brake = 1;
            if (keys['KeyA'] || keys['ArrowLeft']) controls.steer = -1;
            if (keys['KeyD'] || keys['ArrowRight']) controls.steer = 1;
            
            physics.setControls(controls);
            
            // Update physics
            const state = physics.update(deltaTime);
            
            // Update bike position and rotation
            bikeGroup.position.set(
                state.position.x,
                state.position.y,
                state.position.z
            );
            
            bikeGroup.rotation.set(
                state.rotation.pitch,
                state.rotation.yaw,
                state.rotation.roll
            );
            
            // Rotate wheels
            frontWheel.rotation.x += state.speed * deltaTime * 0.05;
            rearWheel.rotation.x += state.speed * deltaTime * 0.05;
            
            // Add trail marker
            addTrailMarker(bikeGroup.position);
            
            // Update camera to follow bike
            const cameraOffset = new THREE.Vector3(0, 5, -10);
            cameraOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), state.rotation.yaw);
            camera.position.lerp(
                new THREE.Vector3(
                    state.position.x + cameraOffset.x,
                    5,
                    state.position.z + cameraOffset.z
                ),
                0.1
            );
            camera.lookAt(bikeGroup.position);
            
            // Update HUD
            document.getElementById('speedometer').textContent = `${Math.round(state.speed)} MPH`;
            document.getElementById('info').innerHTML = `
                Position: X:${state.position.x.toFixed(1)} Z:${state.position.z.toFixed(1)}<br>
                Speed: ${state.speed.toFixed(1)} MPH<br>
                Gear: ${state.gear}<br>
                RPM: ${state.rpm}<br>
                Lean: ${state.leanAngle.toFixed(1)}°<br>
                Turn Rate: ${state.turnRate.toFixed(1)}°/s<br>
                Controls: T:${controls.throttle.toFixed(1)} B:${controls.brake.toFixed(1)} S:${controls.steer.toFixed(1)}
            `;
            
            // Render
            renderer.render(scene, camera);
        }
        
        animate();
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>